=================
Ressource Caching
=================

We are caching the bodies of resources. The cache removes objects a given time
after the last access, by default 30 days.

>>> import zeit.connector.cache
>>> cache = zeit.connector.cache.ResourceCache()


Let's set the cache timeout to 4 second, since we don't want to wait 30 days:

>>> cache.CACHE_TIMEOUT = 4
>>> cache.UPDATE_INTERVAL = 0.9

For getting data from the cache, the cache needs the etag from the properties:

>>> properties = {('getetag', 'DAV:'): 'hurz'}

Initially the cache is empty and asking for a non  cached entry yields a
KeyError.:

>>> cache.getData('some-id', properties)
Traceback (most recent call last):
    ...
KeyError: "Object 'some-id' is not cached."


Set some data. `setData` returns either a StringIO or an open file handle. What
it returns depends on the size of the input data. For small data is returned as
StringIO:

>>> from StringIO import StringIO
>>> data = StringIO('datadata/end of line.')
>>> file_handle = cache.setData('some-id', properties, data)
>>> file_handle
<cStringIO.StringI object at 0x...>
>>> file_handle.read()
'datadata/end of line.'

We can get the data also via `getData` now which also returns a StringIO for
small objects:

>>> cache.getData('some-id', properties)
<cStringIO.StringI object at 0x...>

We have data in the cache. Since it's a small object it is stored as a
reference to a plain string:

>>> from zeit.connector.cache import get_storage_key
>>> cached = cache._data[get_storage_key('some-id')]
>>> cached
<zeit.connector.cache.StringRef object at 0x...>
>>> cached._str
'datadata/end of line.'
>>> cached.open('r')
<cStringIO.StringI object at 0x...>
>>> cached.open('r').read()
'datadata/end of line.'
>>> cache._etags[get_storage_key('some-id')]
'hurz'

Also the access times are noted in the cache:

>>> last_access = cache._last_access_time[get_storage_key('some-id')]
>>> isinstance(last_access, (int, long))
True
>>> get_storage_key(cache._time_to_id[last_access])
'some-id'

When we now access getData the access time will not be update since less than
1 second has passed:

>>> cache.getData('some-id', properties)
<cStringIO.StringI object at 0x...>
>>> cache._last_access_time[get_storage_key('some-id')] == last_access
True

Let's wait 1 second:

>>> import time
>>> time.sleep(1)

If we access now the time will be updated:


>>> cache.getData('some-id', properties)
<cStringIO.StringI object at 0x...>
>>> new_access = cache._last_access_time[get_storage_key('some-id')]
>>> new_access == last_access
False

Also the the time to id mapping has been updated:

>>> cache._time_to_id[last_access]
Traceback (most recent call last):
    ...
KeyError: ...
>>> get_storage_key(cache._time_to_id[new_access])
'some-id'


Add another resource to the cache to see how resources are removed from the
cache:

>>> data = StringIO('another text')
>>> cache.setData('another-id', properties, data)
<cStringIO.StringI object at 0x...>

We now have two elements in the cache:

>>> sorted(get_storage_key(k) for k in cache._last_access_time.keys())
['another-id', 'some-id']

Now sleep another 4 seconds and see the `some-id` will be gone after accessing:

>>> time.sleep(1)
>>> cache.getData('another-id', properties)
<cStringIO.StringI object at 0x...>
>>> sorted(get_storage_key(k) for k in cache._last_access_time.keys())
['another-id', 'some-id']

Still there ...

>>> time.sleep(1)
>>> cache.getData('another-id', properties)
<cStringIO.StringI object at 0x...>
>>> sorted(get_storage_key(k) for k in cache._last_access_time.keys())
['another-id', 'some-id']

Still there ...

>>> time.sleep(1)
>>> cache.getData('another-id', properties)
<cStringIO.StringI object at 0x...>
>>> sorted(get_storage_key(k) for k in cache._last_access_time.keys())
['another-id', 'some-id']

Now it's gone:

>>> time.sleep(1)
>>> cache.getData('another-id', properties)
<cStringIO.StringI object at 0x...>
>>> sorted(get_storage_key(k) for k in cache._last_access_time.keys())
['another-id']

We don't have any data stored for the key now:

>>> cache._data[get_storage_key('some-id')]
Traceback (most recent call last):
    ...
KeyError: ...
>>> cache._etags[get_storage_key('some-id')]
Traceback (most recent call last):
    ...
KeyError: ...


For large objects we store a blob. What a large object is, is determined by the
buffer size:

>>> cache.BUFFER_SIZE
10240

Create data which is large than that:


>>> large_data = 'Large' + ('Data' * cache.BUFFER_SIZE)
>>> 
>>> file_handle = cache.setData(
...     'some-id', properties, StringIO(large_data))
>>> file_handle
<open file '...', mode 'rb' at 0x...>
>>> file_handle.read() == large_data
True

We can get the data also via `getData` now which also returns a StringIO for
small objects:

>>> cache.getData('some-id', properties)
<open file '...', mode 'rb' at 0x...>

Internally a blob is created in this case:

>>> cache._data[get_storage_key('some-id')]
<ZODB.blob.Blob object at 0x...>


Property Cache
==============

The property cache is invalidated by the ResourceInvalidatedEvent. This is

>>> cache = zeit.connector.cache.PropertyCache()

Validate the interface:

>>> import zope.interface.verify
>>> zope.interface.verify.verifyObject(
...     zeit.connector.interfaces.IPersistentCache,
...     cache)
True

Test the methods:

>>> cache['id'] = {'foo': 'bar'}
>>> cache['id']
{<WebDAVPropertyKey foo>: 'bar'}
>>> cache.get('id')
{<WebDAVPropertyKey foo>: 'bar'}
>>> cache.get('foo', "don't have that")
"don't have that"

>>> 'id' in cache
True
>>> 'blafasel' in cache
False

>>> del cache['id']
>>> cache['id']
Traceback (most recent call last):
    ...
KeyError: 'id'

>>> cache.get('id') is None
True

Note that there is actually still the entry in the cache, but marked as
deleted:

>>> cache._storage['id']
<BTrees.OOBTree.OOBTree object at 0x...>
>>> list(cache._storage['id'])
[DeleteProperty]

The property cache does some magic to prevent extensive memory consumption. The
keys in the cache *value* are rather few, maybe 200. So it keeps track of the
different keys and stores/returns references to already passed ones.

>>> key = ('ns', 'name')
>>> properties = {key: 'somevalue'}
>>> cache['id'] = properties

Store another property set with another instance of "key":

>>> key2 = ('ns', 'name')
>>> key == key2
True
>>> key is key2
False

>>> cache['otherid'] = {key2: 'othervalue'}

When we get the properties of 'otherid' back, the key2 is the same instance as
key:

>>> key2_back = cache['otherid'].keys()[0]
>>> key2_back == key2 == key
True
>>> key2_back is key2
False

>>> import pprint
>>> pprint.pprint(zeit.connector.cache.WebDAVPropertyKey._instances)
{'foo': <WebDAVPropertyKey foo>,
 ('ns', 'name'): <WebDAVPropertyKey ('ns', 'name')>}



Note that internally no dictionaries are stored but BTrees:

>>> cache._storage['id']
<BTrees.OOBTree.OOBTree object at 0x...>


Child Name Cache
================

The childname cache just stores a mapping of unique id to a list of child
names:

>>> cache = zeit.connector.cache.ChildNameCache()
>>> cache['id'] = ['foo', 'bar', 'baz']

The data is returned as a TreeSet. That also means the a list will be sorted:

>>> cache['id']
<BTrees.OOBTree.OOTreeSet object at 0x...>
>>> list(cache['id'])
['bar', 'baz', 'foo']

When we remove things from the cache they're gone:

>>> del cache['id']
>>> cache['id']
Traceback (most recent call last):
    ...
KeyError: 'id'

>>> cache.get('id') is None
True

But actually the're just marked as deleted:

>>> cache._storage['id']
<BTrees.OOBTree.OOTreeSet object at 0x...>
>>> list(cache._storage['id'])
[DeleteProperty]
