==========================
Functional connector tests
==========================

Test the integration with zope 3.

>>> import zope.app.component.hooks
>>> old_site = zope.app.component.hooks.getSite()
>>> zope.app.component.hooks.setSite(getRootFolder())

Get the connector:

>>> import zope.component
>>> import zeit.connector.interfaces
>>> connector = zope.component.getUtility(
...     zeit.connector.interfaces.IConnector)
>>> connector
<zeit.connector.zopeconnector.ZopeConnector object at 0x...>


Get a folder:

>>> connector['http://xml.zeit.de/testing']
<zeit.connector.resource.CachedResource object at 0x...>

Get a file-like resource:

>>> res = connector['http://xml.zeit.de/index']
>>> res
<zeit.connector.resource.CachedResource object at 0x...>
>>> res.data
<open file '...', mode 'rb' at 0x...>

After committing we'll still get a file back:

>>> import transaction
>>> transaction.commit()
>>> res = connector['http://xml.zeit.de/index']
>>> res.data
<open file '...', mode 'rb' at 0x...>

The directory listing is empty:

>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[]


There was a bug that the property changes where not visible when using
``changeProperties``. Now we get the properties back:

>>> import StringIO
>>> id = 'http://xml.zeit.de/testing/prop-change'
>>> res = zeit.connector.resource.Resource(
...     id, 'propchange', 'text',
...     StringIO.StringIO('Pop goes the weasel!'),
...     contentType='text/plain')
>>> connector.add(res)
>>> connector.changeProperties(
...     id, {('colour', 'http://namespaces.zeit.de/test'): u'gr\xfcn'})
>>> res_got = connector[id]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
u'gr\xfcn'
>>> del connector[id]
>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[]


Invalidation events
===================

When an `IResourceInvalidatedEvent` is issued the caches remove their
information about the event's resource. Let's fill the property-cache:

>>> property_cache = zope.component.getUtility(
...     zeit.connector.interfaces.IPropertyCache)
>>> property_cache['resource-id'] = {'foo': 'bar'}
>>> property_cache['another-id'] = {'bar': 'baz'}
>>> property_cache['yet-another-id'] = {'nu': 'jazz'}

Let's also fill the childname cache:

>>> child_name_cache = zope.component.getUtility(
...     zeit.connector.interfaces.IChildNameCache)
>>> child_name_cache['resource-id'] = ['abc']
>>> child_name_cache['another-id'] = ['def']
>>> child_name_cache['yet-another-id'] = ['ghi']


Invalidate `another-id` via an event:

>>> import zope.event
>>> zope.event.notify(
...     zeit.connector.interfaces.ResourceInvaliatedEvent('another-id'))

The data is gone now:

>>> import pprint
>>> from zeit.connector.cache import get_storage_key
>>> pprint.pprint(sorted(
...     get_storage_key(k) for k in property_cache._storage.keys()
...     if property_cache.get(k)))
['http://xml.zeit.de/index',
 'http://xml.zeit.de/testing/',
 'resource-id',
 'yet-another-id']
>>> pprint.pprint(
...     sorted(get_storage_key(k) for k in child_name_cache._storage.keys()
...     if property_cache.get(k)))
['http://xml.zeit.de/testing/',
 'resource-id',
 'yet-another-id']

Nothing special happens when the caches do not know anything about the resource
anyway:

>>> zope.event.notify(
...     zeit.connector.interfaces.ResourceInvaliatedEvent('another-id'))




Transaction integration
=======================

Locking
-------

When an object is locked and the transaction is rolled back, the object will be
automatically unlocked.

>>> id = 'http://xml.zeit.de/testing/lockrollback'
>>> res = zeit.connector.resource.Resource(
...     id, 'lockrollback', 'text',
...     StringIO.StringIO('Pop goes the weasel!'),
...     contentType='text/plain')
>>> connector.add(res)
>>> connector.lock(res.id, 'frodo', until=None)
'opaquelocktoken:...'
>>> connector.locked(res.id)
(u'frodo', datetime.datetime(...), True)

Now rollback:

>>> import transaction
>>> transaction.abort()

The resource is no longer locked:

>>> connector.locked(res.id)
(None, None, False)


Make sure the resource stays locked on commit:

>>> connector.lock(res.id, 'frodo', until=None)
'opaquelocktoken:...'
>>> transaction.commit()
>>> connector._invalidate_cache(res.id)
>>> connector.locked(res.id)
(u'frodo', datetime.datetime(...), True)

Remove the resource to clean up:

>>> del connector[res.id]

Threading
=========

We've got some problems with parallel accesses.

>>> import thread
>>> import threading
>>> import zeit.connector.resource
>>> import zeit.connector.test
>>> import StringIO
>>> log = {}
>>> checker = []
>>> import transaction

>>> def create_struct():
...     transaction.abort()
...     base = 'http://xml.zeit.de/testing/%s' % (
...         str(thread.get_ident()).encode('base64')[:-3])
...     import zope.app.component.hooks
...     zope.app.component.hooks.setSite(getRootFolder())
...
...     def add_folder(id):
...         id = u'%s/%s' % (base, id)
...         res = zeit.connector.resource.Resource(
...             id, None, 'folder', StringIO.StringIO(''),
...             contentType = 'httpd/unix-directory')
...         connector.add(res)
...     def add_file(id):
...         id = u'%s/%s' % (base, id)
...         res = zeit.connector.resource.Resource(
...             id, None, 'text', StringIO.StringIO('Pop.'),
...             contentType = 'text/plain')
...         connector.add(res)
...
...     try:
...         add_folder('')
...         add_folder('testroot')
...         add_folder('testroot/a')
...         add_folder('testroot/a/a')
...         transaction.commit()
...         add_folder('testroot/a/b')
...         add_folder('testroot/a/b/c')
...         add_folder('testroot/b')
...         add_folder('testroot/b/a')
...         add_folder('testroot/b/b')
...         add_file('testroot/f')
...         add_file('testroot/g')
...         add_file('testroot/h')
...         add_file('testroot/a/f')
...         add_file('testroot/a/b/c/foo')
...         add_file('testroot/b/b/foo')
...         transaction.commit()
...     except Exception, e:
...         import traceback
...         traceback.print_exc()
...
...     result = zeit.connector.test.list_tree(
...         connector, base)
...     checker.append([r.replace(base, '') for r in result])
...     try:
...         del connector[base]
...     except Exception, e:
...         import traceback
...         traceback.print_exc()

>>> threads = []
>>> while len(threads) < 10:
...     threads.append(threading.Thread(target=create_struct))
>>> for t in threads:
...     t.start()
>>> for t in threads:
...     t.join()

>>> result = [
...     '',
...     u'/testroot/ folder',
...     u'/testroot/a/ folder',
...     u'/testroot/a/a/ folder',
...     u'/testroot/a/b/ folder',
...     u'/testroot/a/b/c/ folder',
...     u'/testroot/a/b/c/foo text',
...     u'/testroot/a/f text',
...     u'/testroot/b/ folder',
...     u'/testroot/b/a/ folder',
...     u'/testroot/b/b/ folder',
...     u'/testroot/b/b/foo text',
...     u'/testroot/f text',
...     u'/testroot/g text',
...     u'/testroot/h text']

>>> len(checker)
10
>>> checker = [c for c in checker if c != result]
>>> checker
[]



After tests we clean up:

>>> zope.app.component.hooks.setSite(old_site)
