==========================
Functional connector tests
==========================

Test the integration with zope 3.

>>> import zope.app.component.hooks
>>> old_site = zope.app.component.hooks.getSite()
>>> zope.app.component.hooks.setSite(getRootFolder())

Get the connector:

>>> import zope.component
>>> import zeit.connector.interfaces
>>> connector = zope.component.getUtility(
...     zeit.connector.interfaces.IConnector)
>>> connector
<zeit.connector.zopeconnector.ZopeConnector object at 0x...>


Get a folder:

>>> connector['http://xml.zeit.de/testing']
<zeit.connector.resource.CachedResource object at 0x...>

Get a file-like resource:

>>> res = connector['http://xml.zeit.de/index']
>>> res
<zeit.connector.resource.CachedResource object at 0x...>
>>> res.data
<open file '...', mode 'rb' at 0x...>

After committing we'll still get a file back:

>>> import transaction
>>> transaction.commit()
>>> res = connector['http://xml.zeit.de/index']
>>> res.data
<open file '...', mode 'rb' at 0x...>

The directory listing is empty:

>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[]


There was a bug that the property changes where not visible when using
``changeProperties``. Now we get the properties back:

>>> import StringIO
>>> id = 'http://xml.zeit.de/testing/prop-change'
>>> res = zeit.connector.resource.Resource(
...     id, 'propchange', 'text',
...     StringIO.StringIO('Pop goes the weasel!'),
...     contentType='text/plain')
>>> connector.add(res)
>>> connector.changeProperties(
...     id, {('colour', 'http://namespaces.zeit.de/test'): u'gr\xfcn'})
>>> res_got = connector[id]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
u'gr\xfcn'
>>> del connector[id]
>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[]


Invalidation events
===================

When an `IResourceInvalidatedEvent` is issued the caches remove their
information about the event's resource. Let's fill the property-cache:

>>> property_cache = zope.component.getUtility(
...     zeit.connector.interfaces.IPropertyCache)
>>> property_cache['resource-id'] = {'foo': 'bar'}
>>> property_cache['another-id'] = {'bar': 'baz'}
>>> property_cache['yet-another-id'] = {'nu': 'jazz'}

Let's also fill the childname cache:

>>> child_name_cache = zope.component.getUtility(
...     zeit.connector.interfaces.IChildNameCache)
>>> child_name_cache['resource-id'] = ['abc']
>>> child_name_cache['another-id'] = ['def']
>>> child_name_cache['yet-another-id'] = ['ghi']


Invalidate `another-id` via an event:

>>> import zope.event
>>> zope.event.notify(
...     zeit.connector.interfaces.ResourceInvaliatedEvent('another-id'))

The data is gone now:

>>> import pprint
>>> from zeit.connector.cache import get_storage_key
>>> pprint.pprint(sorted(
...     get_storage_key(k) for k in property_cache._storage.keys()
...     if property_cache.get(k)))
['http://xml.zeit.de/index',
 'http://xml.zeit.de/testing/',
 'resource-id',
 'yet-another-id']
>>> pprint.pprint(
...     sorted(get_storage_key(k) for k in child_name_cache._storage.keys()
...     if property_cache.get(k)))
['http://xml.zeit.de/testing/',
 'resource-id',
 'yet-another-id']

Nothing special happens when the caches do not know anything about the resource
anyway:

>>> zope.event.notify(
...     zeit.connector.interfaces.ResourceInvaliatedEvent('another-id'))




Transaction integration
=======================

Locking
-------

When an object is locked and the transaction is rolled back, the object will be
automatically unlocked.

>>> id = 'http://xml.zeit.de/testing/lockrollback'
>>> res = zeit.connector.resource.Resource(
...     id, 'lockrollback', 'text',
...     StringIO.StringIO('Pop goes the weasel!'),
...     contentType='text/plain')
>>> connector.add(res)
>>> connector.lock(res.id, 'frodo', until=None)
'opaquelocktoken:...'
>>> connector.locked(res.id)
(u'frodo', datetime.datetime(...), True)

Now rollback:

>>> import transaction
>>> transaction.abort()

The resource is no longer locked:

>>> connector.locked(res.id)
(None, None, False)


Make sure the resource stays locked on commit:

>>> connector.lock(res.id, 'frodo', until=None)
'opaquelocktoken:...'
>>> transaction.commit()
>>> connector._invalidate_cache(res.id)
>>> connector.locked(res.id)
(u'frodo', datetime.datetime(...), True)

Remove the resource to clean up:

>>> del connector[res.id]


Referrers
=========

When the interaction has an URL we set the referrer header:

>>> transaction.commit()
>>> import zope.publisher.browser
>>> import zope.security.management
>>> request = zope.publisher.browser.TestRequest()
>>> zope.security.management.newInteraction(request)


Enable debugging of the http data:

>>> import zeit.connector.dav.davbase
>>> zeit.connector.dav.davbase.DEBUG_CONNECTION = True

>>> connector._invalidate_cache('http://xml.zeit.de/testing/')
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
connect: (zip6.zeit.de, 9000)
send: 'HEAD ...\r\nReferer: http://127.0.0.1\r\n...
...
[]

Reset:

>>> zope.security.management.endInteraction()
>>> zeit.connector.dav.davbase.DEBUG_CONNECTION = False


After tests we clean up:

>>> zope.app.component.hooks.setSite(old_site)
