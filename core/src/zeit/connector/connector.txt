=========
Connector
=========

Creating a connector[#loghandler]_:

>>> import zeit.connector.interfaces
>>> import zope.component
>>> connector = zope.component.getUtility(zeit.connector.interfaces.IConnector)

>>> connector
<zeit.connector.connector.Connector object at 0x...>

IConnector Interface
====================

Verify the IConnector interface:

>>> import zope.interface.verify
>>> from zeit.connector.interfaces import IConnector
>>> zope.interface.verify.verifyClass(IConnector, connector.__class__)
True
>>> zope.interface.verify.verifyObject(IConnector, connector)
True



Resources
=========


Get an object. We will get a cached resource:

>>> index_id = "http://xml.zeit.de/index"
>>> resource = connector[index_id]
>>> resource
<zeit.connector.resource.CachedResource object at 0x...>
>>> print resource.data.read()
<?xml ...
<centerpage ...


If a resource does not exist, a KeyError is raised:

>>> connector['http://xml.zeit.de/foobar']
Traceback (most recent call last):
    ...
KeyError: "The resource u'http://xml.zeit.de/foobar' does not exist."

The properties are cached now:

>>> properties = connector.property_cache[index_id]
>>> len(properties) > 0
True

We can also get directory resources:

>>> resource = connector['http://xml.zeit.de/testing/']
>>> resource.type
'collection'
>>> resource.__name__
u'testing'

Storing an object. The object will be created when not yet there.
Don't forget content-type:

>>> import StringIO
>>> from zeit.connector.resource import Resource
>>> res = Resource('http://xml.zeit.de/testing/conn1',
...                'conn1',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> res.id in connector
False
>>> connector.add(res)
>>> res.id in connector
True

We've set `text` as resource type, so we get `text` back, when getting the
resource:

>>> connector[res.id].type
'text'

We also find `conn1` in the collection now:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'conn1', u'http://xml.zeit.de/testing/conn1')]

Resources may be locked:

>>> from datetime import datetime, timedelta
>>> import pytz
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(None, None, False)
>>> token = connector.lock('http://xml.zeit.de/testing/conn1',
...                        'http://xml.zeit.de/users/frodo',
...                        datetime.now(pytz.UTC) + timedelta(hours=2))
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(u'http://xml.zeit.de/users/frodo', datetime.datetime(..., tzinfo=...), True)

The whole lock-information is stored in the lockinfo utility:

>>> lockinfo = connector.locktokens
>>> lockinfo.get('http://xml.zeit.de/testing/conn1')
('opaquelocktoken:...',
 'http://xml.zeit.de/users/frodo',
 datetime.datetime(..., tzinfo=<UTC>))


To unlock it, you would have to supply the locktoken. The library takes
care of that, though:

>>> connector.unlock('http://xml.zeit.de/testing/conn1')
u'opaquelocktoken:...'
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(None, None, False)
>>> lockinfo.get('http://xml.zeit.de/testing/conn1') is None
True

To specify an infinte lock, timeout can be None:

>>> token = connector.lock(
...     'http://xml.zeit.de/testing/conn1',
...     'frodo', until=None)
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(u'frodo', datetime.datetime(9998, 12, 31, 23, 59, 59, 999999, tzinfo=<UTC>),
 True)
>>> connector.unlock('http://xml.zeit.de/testing/conn1')
u'opaquelocktoken:...'

Remove the `conn1` after user:

>>> del connector['http://xml.zeit.de/testing/conn1']
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

The object can be also stored dictionary-style:

>>> res.data = StringIO.StringIO("Round and round the cobbler's bench")
>>> connector["http://xml.zeit.de/testing/conn2"] = res
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'conn2', u'http://xml.zeit.de/testing/conn2')]

The trailing slash is the usual decoration for collections, but should be optional

>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[(u'conn2', u'http://xml.zeit.de/testing/conn2')]

But remove `conn2` again, as we have no further use:

>>> del connector['http://xml.zeit.de/testing/conn2']
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

Resources also have properties, which can be set/changed/unset,
always indexed by a namespace/name pair.
Note: name comes first -- don't ask me why:

>>> token = connector.lock('http://xml.zeit.de/testing/conn3',
...                        'http://xml.zeit.de/users/frodo',
...                        datetime.now(pytz.UTC) + timedelta(hours=2))
>>> res.data = StringIO.StringIO("Mary had a little lamb")
>>> res.properties[('colour', 'http://namespaces.zeit.de/test')] = (
...     'bright blue')
>>> res.properties[('colour', 'http://namespaces.zeit.de/test2')] = (
...     'light sea green')
>>> connector["http://xml.zeit.de/testing/conn3"] = res

The properties and data are stored on the server now. Get the resource again:

>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
'bright blue'
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test2')]
'light sea green'
>>> res_got.data.read()
'Mary had a little lamb'

We can change properties explicitly using `changeProperties`:

>>> connector.changeProperties(
...     'http://xml.zeit.de/testing/conn3',
...     {('colour', 'http://namespaces.zeit.de/test'): u'gr\xfcn'})
>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
u'gr\xfcn'

Make sure we don't get None values:

>>> res_got.properties[('resourcetype', 'DAV:')]
u''




Resources can be overwritten by just assigning them again:

>>> res.data = StringIO.StringIO("Mary had two little lambs")
>>> connector["http://xml.zeit.de/testing/conn3"] = res
>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.data.read()
'Mary had two little lambs'



Unlock the resource again:

>>> connector.unlock('http://xml.zeit.de/testing/conn3')
u'opaquelocktoken:...'

Delete the resource:

>>> del connector["http://xml.zeit.de/testing/conn3"]
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

Collections
===========

Creating collections works like creating any other resource. Create a resource
object first:

>>> import zeit.connector.resource
>>> collection_id = 'http://xml.zeit.de/testing/my-collection/'
>>> coll = zeit.connector.resource.Resource(
...     collection_id, 'my-collection', 'collection', StringIO.StringIO(''))

Add the collection rssource to the dav and see we get it back:

>>> connector.add(coll)
>>> res = connector[collection_id]
>>> res.type
'collection'

Initially a collection is empty:

>>> list(connector.listCollection(collection_id))
[]

The trailing slash is canonical for a collection ID, but may be left out: the
content-type is boss:

>>> other_collection_id = 'http://xml.zeit.de/testing/my-other-collection'
>>> coll = zeit.connector.resource.Resource(
...     other_collection_id, 'my-other-collection', 'image-group',
...     StringIO.StringIO(''),
...     contentType='httpd/unix-directory')

Again, add the collection:

>>> connector.add(coll)

... and get it:

>>> res = connector[other_collection_id]
>>> res.type
'image-group'

>>> res.contentType
'httpd/unix-directory'
>>> list(connector.listCollection(other_collection_id))
[]


Re-adding the collection "overwrites" it, i.e. does nothing:

>>> connector.add(coll)


Remove the collections:

>>> del connector[other_collection_id]
>>> del connector[collection_id]


Copying
=======

Content can be copied. This works for single files as well as directories.
Unfortunatly the dav server doesn't support copying collections, so we have to
implement this in the connector.


Try a single file first. Create it:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]
>>> res = Resource('http://xml.zeit.de/testing/copy-test',
...                'conn1',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> connector.add(res)

Now copy:

>>> connector.copy('http://xml.zeit.de/testing/copy-test',
...                'http://xml.zeit.de/testing/copy-target')
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'copy-target', u'http://xml.zeit.de/testing/copy-target'),
 (u'copy-test', u'http://xml.zeit.de/testing/copy-test')]
>>> connector[u'http://xml.zeit.de/testing/copy-target'].type
'text'


Note that copying an object onto another doesn't work:

>>> connector.copy('http://xml.zeit.de/testing/copy-test',
...                'http://xml.zeit.de/testing/copy-target')
Traceback (most recent call last):
    ...
CopyError: Could not copy or move http://xml.zeit.de/testing/copy-test to
    http://xml.zeit.de/testing/copy-target, because target alread exists.

Copying an non existing object raises a KeyError:

>>> connector.copy('http://xml.zeit.de/testing/foo',
...                'http://xml.zeit.de/testing/bar')
Traceback (most recent call last):
    ...
KeyError: "The resource u'http://xml.zeit.de/testing/foo' does not exist."

Clean up:

>>> del connector[u'http://xml.zeit.de/testing/copy-target']
>>> del connector[u'http://xml.zeit.de/testing/copy-test']

Now make sure we can copy folders[#create-folder-structure]_:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'testroot', u'http://xml.zeit.de/testing/testroot/')]
>>> connector.copy('http://xml.zeit.de/testing/testroot',
...                'http://xml.zeit.de/testing/copiedtree')
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'copiedtree', u'http://xml.zeit.de/testing/copiedtree/'),
 (u'testroot', u'http://xml.zeit.de/testing/testroot/')]


Verify the whole copied tree:

>>> import zeit.connector.testing
>>> zeit.connector.testing.print_tree(
...     connector, 'http://xml.zeit.de/testing/copiedtree')
http://xml.zeit.de/testing/copiedtree
http://xml.zeit.de/testing/copiedtree/a/ folder
http://xml.zeit.de/testing/copiedtree/a/a/ folder
http://xml.zeit.de/testing/copiedtree/a/b/ folder
http://xml.zeit.de/testing/copiedtree/a/b/c/ folder
http://xml.zeit.de/testing/copiedtree/a/b/c/foo text
http://xml.zeit.de/testing/copiedtree/a/f text
http://xml.zeit.de/testing/copiedtree/b/ folder
http://xml.zeit.de/testing/copiedtree/b/a/ folder
http://xml.zeit.de/testing/copiedtree/b/b/ folder
http://xml.zeit.de/testing/copiedtree/b/b/foo text
http://xml.zeit.de/testing/copiedtree/f text
http://xml.zeit.de/testing/copiedtree/g text
http://xml.zeit.de/testing/copiedtree/h text

Make sure copying an folder into a decendent of itself raises an error:

>>> connector.copy('http://xml.zeit.de/testing/testroot',
...                'http://xml.zeit.de/testing/testroot/a/b/c')
Traceback (most recent call last):
    ...
CopyError: Could not copy or move http://xml.zeit.de/testing/testroot to a decendant
    of itself.

Clean up:

>>> del connector['http://xml.zeit.de/testing/copiedtree']
>>> del connector['http://xml.zeit.de/testing/testroot']
    

Moving
======

Content could be moved by removind/adding. This donesn't work nicely with
folders though. So we implement a special method for moving:

Lets create an object which we can move then:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]
>>> res = Resource('http://xml.zeit.de/testing/move-test',
...                'conn1',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> connector.add(res)
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'move-test', u'http://xml.zeit.de/testing/move-test')]


Let's move `move-test` now:

>>> connector.move('http://xml.zeit.de/testing/move-test',
...                'http://xml.zeit.de/testing/move-test-moved')
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'move-test-moved', u'http://xml.zeit.de/testing/move-test-moved')]

Verify the content type:

>>> connector['http://xml.zeit.de/testing/move-test-moved'].type
'text'

We cannot move an object onto another:

>>> res = Resource('http://xml.zeit.de/testing/move-test-2',
...                'conn1',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> connector.add(res)
>>> connector.move('http://xml.zeit.de/testing/move-test-2',
...                'http://xml.zeit.de/testing/move-test-moved')
Traceback (most recent call last):
    ...
MoveError: Could not copy or move http://xml.zeit.de/testing/move-test-2 to
    http://xml.zeit.de/testing/move-test-moved, because target alread exists.


Let's clean up:

>>> del connector['http://xml.zeit.de/testing/move-test-2']
>>> del connector['http://xml.zeit.de/testing/move-test-moved']


Make sure we can also move collections[#create-folder-structure]_:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'testroot', u'http://xml.zeit.de/testing/testroot/')]
>>> connector.move('http://xml.zeit.de/testing/testroot',
...                'http://xml.zeit.de/testing/movedtree')
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'movedtree', u'http://xml.zeit.de/testing/movedtree/')]

Verify the whole structure:

>>> zeit.connector.testing.print_tree(
...     connector, 'http://xml.zeit.de/testing/movedtree')
http://xml.zeit.de/testing/movedtree
http://xml.zeit.de/testing/movedtree/a/ folder
http://xml.zeit.de/testing/movedtree/a/a/ folder
http://xml.zeit.de/testing/movedtree/a/b/ folder
http://xml.zeit.de/testing/movedtree/a/b/c/ folder
http://xml.zeit.de/testing/movedtree/a/b/c/foo text
http://xml.zeit.de/testing/movedtree/a/f text
http://xml.zeit.de/testing/movedtree/b/ folder
http://xml.zeit.de/testing/movedtree/b/a/ folder
http://xml.zeit.de/testing/movedtree/b/b/ folder
http://xml.zeit.de/testing/movedtree/b/b/foo text
http://xml.zeit.de/testing/movedtree/f text
http://xml.zeit.de/testing/movedtree/g text
http://xml.zeit.de/testing/movedtree/h text

Clean up:

>>> del connector[u'http://xml.zeit.de/testing/movedtree']


Internals
=========

Let's test some internals. There is a _make_qname_tuple tuple which splits tag
names in the form {namespace}name to a tuple (name, namespace):

>>> import zeit.connector.dav.davresource
>>> zeit.connector.dav.davresource._make_qname_tuple('{ns}name')
('name', 'ns')

We must be sure that this function also survives tag names w/o namespace:

>>> zeit.connector.dav.davresource._make_qname_tuple('name')
('name', None)

Let's make sure we don't die when the connection gets into an
inconsistent/wrong state:

>>> conn = connector.get_connection()
>>> conn._con
<httplib.HTTPConnection instance at 0x...>
>>> conn._con._HTTPConnection__state
'Idle'
>>> conn._con._HTTPConnection__state = 'flux'
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]



Cleanup and final tests
=======================

Restore log handler:

>>> logging.root.removeHandler(log_handler)
>>> logging.root.setLevel(old_log_level)

Make sure the logfile is empty, as we don't expect anything to be logged in
normal operation:

>>> print logfile.getvalue(),


.. [#create-folder-structure] Create a folder structure for copy/move

    Create helpers for creating folders/files:

    >>> def add_folder(id):
    ...     id = u'http://xml.zeit.de/testing/' + id
    ...     res = Resource(
    ...         id, None, 'folder', StringIO.StringIO(''),
    ...         contentType = 'httpd/unix-directory')
    ...     connector.add(res)
    >>> def add_file(id):
    ...     id = u'http://xml.zeit.de/testing/' + id
    ...     res = Resource(
    ...         id, None, 'text', StringIO.StringIO('Pop.'),
    ...         contentType = 'text/plain')
    ...     connector.add(res)
    
    Create folders:

    >>> add_folder('testroot')
    >>> add_folder('testroot/a')
    >>> add_folder('testroot/a/a')
    >>> add_folder('testroot/a/b')
    >>> add_folder('testroot/a/b/c')
    >>> add_folder('testroot/b')
    >>> add_folder('testroot/b/a')
    >>> add_folder('testroot/b/b')
    
    Create files:

    >>> add_file('testroot/f')
    >>> add_file('testroot/g')
    >>> add_file('testroot/h')
    >>> add_file('testroot/a/f')
    >>> add_file('testroot/a/b/c/foo')
    >>> add_file('testroot/b/b/foo')

    >>> import zeit.connector.tests
    >>> zeit.connector.testing.print_tree(
    ...     connector, 'http://xml.zeit.de/testing/testroot')
    http://xml.zeit.de/testing/testroot
    http://xml.zeit.de/testing/testroot/a/ folder
    http://xml.zeit.de/testing/testroot/a/a/ folder
    http://xml.zeit.de/testing/testroot/a/b/ folder
    http://xml.zeit.de/testing/testroot/a/b/c/ folder
    http://xml.zeit.de/testing/testroot/a/b/c/foo text
    http://xml.zeit.de/testing/testroot/a/f text
    http://xml.zeit.de/testing/testroot/b/ folder
    http://xml.zeit.de/testing/testroot/b/a/ folder
    http://xml.zeit.de/testing/testroot/b/b/ folder
    http://xml.zeit.de/testing/testroot/b/b/foo text
    http://xml.zeit.de/testing/testroot/f text
    http://xml.zeit.de/testing/testroot/g text
    http://xml.zeit.de/testing/testroot/h text
    
.. [#loghandler] We need a log handler

    >>> import logging
    >>> import StringIO
    >>> logfile = StringIO.StringIO()
    >>> log_handler = logging.StreamHandler(logfile)
    >>> logging.root.addHandler(log_handler)
    >>> old_log_level = logging.root.level
    >>> logging.root.setLevel(logging.INFO)

