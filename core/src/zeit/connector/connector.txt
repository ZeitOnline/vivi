=========
Connector
=========

Creating a connector:

>>> import os
>>> from pprint import pprint
>>> from zeit.connector.connector import Connector
>>> from zeit.connector.cache import resourceCacheFactory
>>> connector = Connector(roots={
...       "default": os.environ['connector-url'],
...       "search": os.environ['search-connector-url']})
>>> connector
<zeit.connector.connector.Connector object at 0x...>

IConnector Interface
====================

Verify the IConnector interface:

>>> import zope.interface.verify
>>> from zeit.connector.interfaces import IConnector
>>> zope.interface.verify.verifyClass(IConnector, Connector)
True
>>> zope.interface.verify.verifyObject(IConnector, connector)
True


Cache
=====

Set up a site:

>>> import zope.interface
>>> import zope.app.component.hooks
>>> import zope.annotation.attribute
>>> import zope.annotation.interfaces
>>> from zope.traversing.interfaces import IContainmentRoot
>>> from zope.app.component.interfaces import ISite
>>>
>>> class Site(object):
...     zope.interface.implements(
...         ISite, IContainmentRoot,
...         zope.annotation.interfaces.IAttributeAnnotatable)
...
...     def getSiteManager(self):
...         return zope.component.getGlobalSiteManager()
...
>>> site = Site()
>>> old_site = zope.app.component.hooks.getSite()
>>> zope.app.component.hooks.setSite(site)

And annotations:

>>> site_manager = zope.app.component.hooks.getSiteManager()
>>> site_manager.registerAdapter(
...     zope.annotation.attribute.AttributeAnnotations,
...     (zope.annotation.interfaces.IAttributeAnnotatable,),
...     zope.annotation.interfaces.IAnnotations)


The connector needs the ResourceCache, so we register it:

>>> import zeit.connector.interfaces
>>>
>>> site_manager.registerAdapter(
...     resourceCacheFactory, 
...     (ISite,),
...     zeit.connector.interfaces.IResourceCache)


Resources
=========


Get an object. We will get a cached resource:

>>> index_id = "http://xml.zeit.de/deutschland/index"
>>> ressource = connector[index_id]
>>> ressource
<zeit.connector.resource.CachedResource object at 0x...>
>>> print ressource.data.read()
<?xml ...
<centerpage ...


If a resource does not exist, a KeyError is raised:

>>> connector['http://xml.zeit.de/foobar']
Traceback (most recent call last):
    ...
KeyError: "The resource 'http://xml.zeit.de/foobar' does not exist."

The properties are cached now:

>>> cache = zeit.connector.interfaces.IResourceCache(site)
>>> properties = cache.properties[index_id]
>>> properties[('getcontenttype', 'DAV:')]
'text/xml'


We can also get directory resources:

>>> resource = connector['http://xml.zeit.de/deutschland/']
>>> resource.type
'collection'

Storing an object. The object will be created when not yet there.
Don't forget content-type:

>>> import StringIO
>>> from zeit.connector.resource import Resource
>>> res = Resource('http://xml.zeit.de/testing/conn1',
...                'conn1',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> connector.add(res)

We've set `text` as resource type, so we get `text` back, when getting the
resource:

>>> connector[res.id].type
'text'

We also find `conn1` in the collection now:

>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'conn1', u'http://xml.zeit.de/testing/conn1')]

Resources may be locked:

>>> from datetime import datetime, timedelta
>>> import pytz
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(None, None, False)
>>> token = connector.lock('http://xml.zeit.de/testing/conn1',
...                        'http://xml.zeit.de/users/frodo',
...                        datetime.now(pytz.UTC) + timedelta(hours=2))
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(u'http://xml.zeit.de/users/frodo', datetime.datetime(..., tzinfo=...), True)

To unlock it, you would have to supply the locktoken. The library takes
care of that, though:
>>> connector.unlock('http://xml.zeit.de/testing/conn1')
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(None, None, False)

To specify an infinte lock, timeout can be None:

>>> token = connector.lock(
...     'http://xml.zeit.de/testing/conn1',
...     'frodo', until=None)
>>> connector.locked('http://xml.zeit.de/testing/conn1')
(u'frodo', datetime.datetime(9998, 12, 31, 23, 59, 59, 999999, tzinfo=<UTC>),
 True)
>>> connector.unlock('http://xml.zeit.de/testing/conn1')

Remove the `conn1` after user:

>>> del connector['http://xml.zeit.de/testing/conn1']
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

The object can be also stored dictionary-style:

>>> res.data = StringIO.StringIO("Round and round the cobbler's bench")
>>> connector["http://xml.zeit.de/testing/conn2"] = res
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[(u'conn2', u'http://xml.zeit.de/testing/conn2')]

The trailing slash is the usual decoration for collections, but should be optional

>>> list(connector.listCollection('http://xml.zeit.de/testing'))
[(u'conn2', u'http://xml.zeit.de/testing/conn2')]

But remove `conn2` again, as we have no further use:

>>> del connector['http://xml.zeit.de/testing/conn2']
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

Resources also have properties, which can be set/changed/unset,
always indexed by a namespace/name pair.
Note: name comes first -- don't ask me why:

>>> token = connector.lock('http://xml.zeit.de/testing/conn3',
...                        'http://xml.zeit.de/users/frodo',
...                        datetime.now(pytz.UTC) + timedelta(hours=2))
>>> res.data = StringIO.StringIO("Mary had a little lamb")
>>> res.properties[('colour', 'http://namespaces.zeit.de/test')] = (
...     'bright blue')
>>> connector["http://xml.zeit.de/testing/conn3"] = res

The properties and data are stored on the server now. Get the resource again:

>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
'bright blue'
>>> res_got.data.read()
'Mary had a little lamb'

We can change properties explicitly using `changeProperties`:

>>> connector.changeProperties(
...     'http://xml.zeit.de/testing/conn3',
...     {('colour', 'http://namespaces.zeit.de/test'): u'gr\xfcn'})
>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.properties[('colour', 'http://namespaces.zeit.de/test')]
u'gr\xfcn'


Resources can be overwritten by just assigning them again:

>>> res.data = StringIO.StringIO("Mary had two little lambs")
>>> connector["http://xml.zeit.de/testing/conn3"] = res
>>> res_got = connector["http://xml.zeit.de/testing/conn3"]
>>> res_got.data.read()
'Mary had two little lambs'



Unlock the resource again:

>>> connector.unlock('http://xml.zeit.de/testing/conn3')

Delete the resource:

>>> del connector["http://xml.zeit.de/testing/conn3"]
>>> list(connector.listCollection('http://xml.zeit.de/testing/'))
[]

Collections
===========

Creating collections works like creating any other resource. Create a resource
object first:

>>> collection_id = 'http://xml.zeit.de/testing/my-collection/'
>>> coll = zeit.connector.resource.Resource(
...     collection_id, 'my-collection', 'collection', StringIO.StringIO(''))

Add the collection rssource to the dav and see we get it back:

>>> connector.add(coll)
>>> res = connector[collection_id]
>>> res.type
'collection'

Initially a collection is empty:

>>> list(connector.listCollection(collection_id))
[]

The trailing slash is canonical for a collection ID, but may be left out: the
content-type is boss:

>>> other_collection_id = 'http://xml.zeit.de/testing/my-other-collection'
>>> coll = zeit.connector.resource.Resource(
...     other_collection_id, 'my-other-collection', 'image-group',
...     StringIO.StringIO(''),
...     contentType='httpd/unix-directory')

Again, add the collection:

>>> connector.add(coll)

... and get it:

>>> res = connector[other_collection_id]
>>> res.type
'image-group'

>>> res.contentType
'httpd/unix-directory'
>>> list(connector.listCollection(other_collection_id))
[]


Re-adding the collection "overwrites" it, i.e. does nothing:

>>> connector.add(coll)


Remove the collections:

>>> del connector[other_collection_id]
>>> del connector[collection_id]


Search (interface only):
========================

The building blocks are search vars:

>>> from zeit.connector.search import SearchVar
>>> author = SearchVar('author', 'http://namespaces.zeit.de/document/')
>>> volume = SearchVar('volume', 'http://namespaces.zeit.de/document/')
>>> year = SearchVar('year', 'http://namespaces.zeit.de/document/')
>>> ressort = SearchVar('ressort', 'http://namespaces.zeit.de/document/')

Queries are built of basic terms involving search vars stitched together into
expressions (note that we get dummy values at the moment):

>>> connector.search([author, volume], (year == '2007') & (volume == '07'))
[[u'http://xml.zeit.de/2007/resource-19', "Yers plain ol' dummy, sincerly", "Yers plain ol' dummy, sincerly"],
 [u'http://xml.zeit.de/2007/resource-18', "Yers plain ol' dummy, sincerly", "Yers plain ol' dummy, sincerly"],
 ...]

>>> connector.search([author, volume], (year > '1997') &
...     ((volume == '07') | (volume == '08')) & (ressort == 'Leben'))
[[u'http://xml.zeit.de/2007/resource-19', "Yers plain ol' dummy, sincerly", "Yers plain ol' dummy, sincerly"],
 [u'http://xml.zeit.de/2007/resource-18', "Yers plain ol' dummy, sincerly", "Yers plain ol' dummy, sincerly"],
 ...]


Getting ghost resources
=======================

I'm not sure what this is but listCollection lists a `channel_D` in
`hp_channels` which used to have None as data. This test makes sure we're
retting a file-like object:

>>> 'channel_D' in (name for (name, id) in connector.listCollection(
...                 'http://xml.zeit.de/hp_channels'))
True
>>> channel_d = connector['http://xml.zeit.de/hp_channels/channel_D']
>>> channel_d.data is None
False


Locked resources w/o locking user
=================================

When a resource is locked for instance with cadaver the connector was telling
the resource would not be locked. Verify the bug is fixed. We need the internal
API to create an anonymous lock. Create a resource first:

>>> id = 'http://xml.zeit.de/testing/lock-test'
>>> res = Resource(id,
...                'lock-test',
...                'text',
...                StringIO.StringIO('Pop goes the weasel!'),
...                contentType = 'text/plain')
>>> connector.add(res)

Now lock:

>>> dav_url = connector._id2loc(connector._get_cannonical_id(id))
>>> token = connector._conn().do_lock(dav_url)

The connector tells us it is locked now:

>>> connector.locked(id)
(None, datetime.datetime(9998, 12, 31, 23, 59, 59, 999999, tzinfo=<UTC>),
 False)

Deleting the resource now will yield a `LockingError`:

>>> del connector[id]
Traceback (most recent call last):
    ...
LockingError: Could not delete resource.


Unlock the resource and remove id:

>>> connector._conn().do_unlock(dav_url, token)
>>> del connector[id]


Clean up
========

Cleanup after ourselves:

>>> site_manager.unregisterAdapter(
...     resourceCacheFactory,
...     (ISite,),
...     zeit.connector.interfaces.IResourceCache)
True
>>> site_manager.unregisterAdapter(
...     zope.annotation.attribute.AttributeAnnotations,
...     (zope.annotation.interfaces.IAttributeAnnotatable,),
...     zope.annotation.interfaces.IAnnotations)
True
>>> zope.app.component.hooks.setSite(old_site)
