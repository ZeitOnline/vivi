CDS import
==========

CDS content is imported from a filestore[#functional]_:

>>> import zeit.content.article.cds
>>> fs = zeit.content.article.cds.get_cds_filestore('cds-import')

>>> article_xml = """\
... <?xml version="1.0" encoding="UTF-8"?>
... <article xmlns:py="http://codespeak.net/lxml/objectify/pytype">
...  <body>
...    <supertitle>Neujahrsansprache</supertitle>
...    <title>Jahr der Überraschungen</title>
...    <subtitle>
...      Kanzlerin Angela Merkel ruft die Deutschen auf, sich auch 2007 wieder
...      selbst zu überra schen. Von einer Reformpause will sie nichts wissen
...    </subtitle>
...  </body>
...  <head>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="year">2007</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="volume">2</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="text-length">2000</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...     name="author">Dave Bowman</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...     name="ressort">Wissen</attribute>
...  </head>
... </article>
... """

>>> dummy = with_statement
>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> with fs.create('art2') as f:
...     f.write(article_xml.replace('2007', '2001'))
>>> with fs.create('art3') as f:
...     f.write(article_xml.replace('Wissen', 'Unwissen'))

Move the created files to 'new':

>>> fs.move('art1', 'tmp', 'new')
>>> fs.move('art2', 'tmp', 'new')
>>> fs.move('art3', 'tmp', 'new')


We have data in the filestore now. Call the actual import function. It returns
True as something was imported:

>>> zeit.content.article.cds.import_one()
True

The article was created in the current online working directory (which happens
to be 2008/26):

>>> import zeit.cms.interfaces
>>> container = zeit.cms.interfaces.ICMSContent(
...     'http://xml.zeit.de/online/2008/26')
>>> article = container['art1']
>>> article.year
2007
>>> print article.title
Jahr der Überraschungen
>>> print article.ressort
Wissen

It was last modified by the importer:

>>> import zeit.cms.workflow.interfaces
>>> print zeit.cms.workflow.interfaces.IModified(article).last_modified_by
zope.cds


The article is marked as being a tagesspiegel article:

>>> zeit.content.article.interfaces.ITagesspiegelArticle.providedBy(article)
True

There is a different icon defined for tagesspiegel:

>>> import zeit.cms.browser.interfaces
>>> import zope.publisher.browser
>>> request = zope.publisher.browser.TestRequest(
...     skin=zeit.cms.browser.interfaces.ICMSSkin)
>>> icon = zope.component.queryMultiAdapter(
...     (article, request), name='zmi_icon')
>>> print icon()
<img src="http://127.0.0.1/@@/zeit-content-article-interfaces-ITagesspiegelArticle-zmi_icon.png"...


Looking at the filestore shows us that art1 was moved to cur:

>>> sorted(fs.list('new'))
['.../art2', '.../art3']
>>> fs.list('cur')
['.../art1']

When we call ``import_one`` again it returns True for two more times:

>>> zeit.content.article.cds.import_one()
True
>>> zeit.content.article.cds.import_one()
True
>>> zeit.content.article.cds.import_one()
False

All files have been imported now. art1 and art2 have been imported to the
working area:

>>> list(container)
[u'art1', u'art2']

art3 has an invalid ressort and thus was imported to /cds/invalid/year/volume:

>>> invalid_ressort_container = zeit.cms.interfaces.ICMSContent(
...     'http://xml.zeit.de/cds/invalid/2008/26')
>>> list(invalid_ressort_container)
[u'art3']


Colission detection
+++++++++++++++++++

When an object is imported which is already in the system (determined by UUID),
it will not be imported, *if* it was changed in the CMS.

Import an article with a UUID[#patch-connector]_:

>>> data = article_xml.replace('<head>', """\
... <head><attribute
...     xmlns:py="http://codespeak.net/lxml/objectify/pytype"
...     py:pytype="str"
...     ns="http://namespaces.zeit.de/CMS/document"
...     name="uuid">{urn:uuid:1029cf63-5823-456c-bbd4-1a98cdfa25c7}</attribute>
... """)    
>>> with fs.create('art-uuid') as f:
...     f.write(data)
>>> fs.move('art-uuid', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Jahr der Überraschungen


Without change the article will be overwritten:

>>> search_returns = container['art-uuid'].uniqueId
>>> with fs.create('art-uuid-2') as f:
...     f.write(data.replace('Jahr', 'Monat'))
>>> fs.move('art-uuid-2', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Monat der Überraschungen

When we change the imported article, it is not overwritten:

>>> p = zeit.cms.testing.create_interaction()
>>> import zeit.cms.checkout.helper
>>> with zeit.cms.checkout.helper.checked_out(container['art-uuid']) as co:
...     co.title = u'Tag der Ueberraschungen'
>>> with fs.create('art-uuid-3') as f:
...     f.write(data.replace('Jahr', 'Stunde'))
>>> fs.move('art-uuid-3', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Tag der Ueberraschungen


Same filenames
++++++++++++++

When the same file is imported with a differend UUID (or no UID) articles are
*not* overwritten:


>>> 'art1' in container
True
>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> fs.move('art1', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> list(container)
[u'art-uuid', u'art1', u'art1-2', u'art2']



Runner integration
++++++++++++++++++

For the integration with gocept.runner there is a helper returning different
sleep times, depending on whether there was something imported or not. 

Add a file to the filestore again:

>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> fs.move('art1', 'tmp', 'new')

When something was imported the sleep time is low:

>>> zeit.content.article.cds.import_and_schedule()
0.02

When there was nothing imported the sleep time is higher:

>>> zeit.content.article.cds.import_and_schedule()
10


The real appmain is:

>>> zeit.content.article.cds.import_main
<function import_main at 0x...>





Clean up:

>>> zeit.connector.mock.Connector.search = old_search


.. [#functional]

    >>> import zeit.cms.testing
    >>> zeit.cms.testing.set_site()

.. [#patch-connector] We have to patch the connector, so the search for the
    uuid gives us a useful result:

    >>> import zeit.connector.mock
    >>> search_returns = None
    >>> def new_search(self, metadata, query):
    ...     if search_returns and search_returns in self:
    ...         return [(search_returns,)]
    ...     return []
    >>> old_search = zeit.connector.mock.Connector.search
    >>> zeit.connector.mock.Connector.search = new_search
