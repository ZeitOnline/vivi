CDS import
==========

CDS content is imported from a filestore[#functional]_:

>>> import zeit.content.article.cds
>>> fs = zeit.content.article.cds.get_cds_filestore('cds-import')

>>> article_xml = """\
... <?xml version="1.0" encoding="UTF-8"?>
... <article xmlns:py="http://codespeak.net/lxml/objectify/pytype">
...  <body>
...    <supertitle>Neujahrsansprache</supertitle>
...    <title>Jahr der Überraschungen</title>
...    <subtitle>
...      Kanzlerin Angela Merkel ruft die Deutschen auf, sich auch 2007 wieder
...      selbst zu überra schen. Von einer Reformpause will sie nichts wissen
...    </subtitle>
...  </body>
...  <head>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="year">2007</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="volume">2</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...      name="text-length">2000</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...     name="author">Dave Bowman</attribute>
...    <attribute py:pytype="str" ns="http://namespaces.zeit.de/CMS/document"
...     name="ressort">Wissen</attribute>
...  </head>
... </article>
... """

>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> with fs.create('art2') as f:
...     f.write(article_xml.replace('2007', '2001'))
>>> with fs.create('art3') as f:
...     f.write(article_xml.replace('Wissen', 'Unwissen'))

Move the created files to 'new':

>>> fs.move('art1', 'tmp', 'new')
>>> fs.move('art2', 'tmp', 'new')
>>> fs.move('art3', 'tmp', 'new')


We have data in the filestore now. Call the actual import function. It returns
True as something was imported:

>>> p = zeit.cms.testing.create_interaction()
>>> zeit.content.article.cds.import_one()
True

The article was created in the wissen working directory (which happens
to be 2008/26):

>>> import zeit.cms.interfaces
>>> container = zeit.cms.interfaces.ICMSContent(
...     'http://xml.zeit.de/wissen/2008/26')
>>> article = container['art1']
>>> article.year
2007
>>> print article.title
Jahr der Überraschungen
>>> print article.ressort
Wissen

It was last modified by the importer:

>>> import zeit.cms.workflow.interfaces
>>> print zeit.cms.workflow.interfaces.IModified(article).last_modified_by
zope.cds


The article is marked as being a tagesspiegel article:

>>> zeit.content.article.interfaces.ITagesspiegelArticle.providedBy(article)
True

The information is kept, when the article is checked out and back in:

>>> with zeit.cms.checkout.helper.checked_out(article): pass
>>> article = container['art1']
>>> zeit.content.article.interfaces.ITagesspiegelArticle.providedBy(article)
True

There is a different icon defined for tagesspiegel:

>>> import zeit.cms.browser.interfaces
>>> import zope.publisher.browser
>>> request = zope.publisher.browser.TestRequest(
...     skin=zeit.cms.browser.interfaces.ICMSSkin)
>>> icon = zope.component.queryMultiAdapter(
...     (article, request), name='zmi_icon')
>>> print icon()
<img src="http://127.0.0.1/@@/zeit-content-article-interfaces-ITagesspiegelArticle-zmi_icon.png"...

Also, imported articles will not be exported automatically:

>>> zeit.content.article.interfaces.ICDSWorkflow(article).export_cds
False


Looking at the filestore shows us that art1 was moved to cur:

>>> sorted(fs.list('new'))
['.../art2', '.../art3']
>>> fs.list('cur')
['.../art1']

When we call ``import_one`` again it returns True for two more times:

>>> zeit.content.article.cds.import_one()
True
>>> zeit.content.article.cds.import_one()
True
>>> zeit.content.article.cds.import_one()
False

All files have been imported now. art1 and art2 have been imported to the
working area:

>>> list(container)
[u'art1', u'art2']

art3 has an invalid ressort and thus was imported to /cds/invalid/year/volume:

>>> invalid_ressort_container = zeit.cms.interfaces.ICMSContent(
...     'http://xml.zeit.de/cds/invalid/2008/26')
>>> list(invalid_ressort_container)
[u'art3']


Colission detection
+++++++++++++++++++

When an object is imported which is already in the system (determined by UUID),
it will not be imported, *if* it was changed in the CMS.

Import an article with a UUID[#patch-connector]_:

>>> data = article_xml.replace('<head>', """\
... <head><attribute
...     xmlns:py="http://codespeak.net/lxml/objectify/pytype"
...     py:pytype="str"
...     ns="http://namespaces.zeit.de/CMS/document"
...     name="uuid">{urn:uuid:1029cf63-5823-456c-bbd4-1a98cdfa25c7}</attribute>
... """)    
>>> with fs.create('art-uuid') as f:
...     f.write(data)
>>> fs.move('art-uuid', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Jahr der Überraschungen


Without change the article will be overwritten:

>>> search_returns = container['art-uuid'].uniqueId
>>> with fs.create('art-uuid-2') as f:
...     f.write(data.replace('Jahr', 'Monat'))
>>> fs.move('art-uuid-2', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Monat der Überraschungen

When we change the imported article, it is not overwritten:

>>> import zeit.cms.checkout.helper
>>> with zeit.cms.checkout.helper.checked_out(container['art-uuid']) as co:
...     co.title = u'Tag der Ueberraschungen'
>>> with fs.create('art-uuid-3') as f:
...     f.write(data.replace('Jahr', 'Stunde'))
>>> fs.move('art-uuid-3', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> print container['art-uuid'].title
Tag der Ueberraschungen


Same filenames
++++++++++++++

When the same file is imported with a differend UUID (or no UID) articles are
*not* overwritten:


>>> 'art1' in container
True
>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> fs.move('art1', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> list(container)
[u'art-uuid', u'art1', u'art1-2', u'art2']


Automatic removal of unpublished articles
+++++++++++++++++++++++++++++++++++++++++

Articles which were imported from the CDS and are not published within two days
are deleted automatically in the night after those two days have passed.

When importing an article, a job will be scheduled for 2 days + something:

>>> with fs.create('auto-delete') as f:
...     f.write(article_xml)
>>> fs.move('auto-delete', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> 'auto-delete' in container
True

When we process the tasks now, nothing happens:

>>> tasks.process()
>>> 'auto-delete' in container
True

After the scheduled time has arrived, the article is gone:

>>> import datetime
>>> import time
>>> def new_now():
...     now = datetime.datetime.now() + datetime.timedelta(days=3)
...     return float(now.strftime('%s'))
>>> old_now = time.time
>>> time.time = new_now
>>> tasks.process()
>>> 'auto-delete' in container
False

When an article is published in the meantime, it will not be deleted:

>>> with fs.create('auto-delete') as f:
...     f.write(article_xml)
>>> fs.move('auto-delete', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> 'auto-delete' in container
True

Make the article published:

>>> import zeit.cms.workflow
>>> import zeit.content.article.interfaces
>>> class PublishInfo(object):
...     def __init__(self, context):
...         pass
...     published = True
>>> gsm = zope.component.getGlobalSiteManager()
>>> gsm.registerAdapter(
...     PublishInfo, (zeit.content.article.interfaces.IArticle,),
...     zeit.cms.workflow.interfaces.IPublishInfo)

When the removal time has come, the object will not be removed:

>>> time.time = new_now
>>> tasks.process()
>>> time.time = old_now
>>> 'auto-delete' in container
True


Remove the published adapter:

>>> gsm.unregisterAdapter(
...     PublishInfo, (zeit.content.article.interfaces.IArticle,),
...     zeit.cms.workflow.interfaces.IPublishInfo)
True


Broken XML
++++++++++

When the XML of an imported file xml doesn't parse, they're (obviously not
imported), but no error is raises on the other hand. An error will be logged
though:

>>> with fs.create('invalid-xml') as f:
...     f.write('snafu')
>>> fs.move('invalid-xml', 'tmp', 'new')
>>> zeit.content.article.cds.import_one()
True
>>> zeit.content.article.cds.import_one()
False


Runner integration
++++++++++++++++++

For the integration with gocept.runner there is a helper returning different
sleep times, depending on whether there was something imported or not. 

Add a file to the filestore again:

>>> with fs.create('art1') as f:
...     f.write(article_xml)
>>> fs.move('art1', 'tmp', 'new')

When something was imported the sleep time is low:

>>> zeit.content.article.cds.import_and_schedule()
10

When there was nothing imported the sleep time is higher:

>>> zeit.content.article.cds.import_and_schedule()
60


The real appmain is:

>>> zeit.content.article.cds.import_main
<function import_main at 0x...>


Replacements
++++++++++++

>>> import datetime
>>> import mock
>>> import pytz
>>> new_dt = mock.Mock()
>>> new_dt.datetime = mock.Mock()
>>> new_dt.datetime.now = mock.Mock(return_value=datetime.datetime(
...     2008, 8, 5, tzinfo=pytz.UTC))
>>> new_dt.timedelta = datetime.timedelta
>>> zeit.content.article.cds.datetime = new_dt
>>> import pprint
>>> pprint.pprint(zeit.content.article.cds.get_replacements(article))
{'real_day': '05',
 'real_month': '08',
 'real_year': '2008',
 'ressort': u'wissen',
 'sub_ressort': u''}


Clean up:

>>> zeit.connector.mock.Connector.search = old_search
>>> zeit.content.article.cds.datetime = datetime


.. [#functional]

    >>> import zeit.cms.testing
    >>> zeit.cms.testing.set_site()

    >>> import zope.component
    >>> import lovely.remotetask.interfaces
    >>> tasks = zope.component.getUtility(
    ...     lovely.remotetask.interfaces.ITaskService, 'general')

.. [#patch-connector] We have to patch the connector, so the search for the
    uuid gives us a useful result:

    >>> import zeit.connector.mock
    >>> search_returns = None
    >>> def new_search(self, metadata, query):
    ...     if search_returns and search_returns in self:
    ...         return [(search_returns,)]
    ...     return []
    >>> old_search = zeit.connector.mock.Connector.search
    >>> zeit.connector.mock.Connector.search = new_search

