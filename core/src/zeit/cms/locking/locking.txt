=======
Locking
=======

The acutual locking is done via WebDAV. 


Setup
=====

Mock a connector:

>>> import zope.component
>>> class Connector(object):
...     who = None
...     until = None
...     mylock = True
...     def locked(self, id):
...         return self.who, self.until, self.mylock
... 
>>> import zope.component
>>> import zeit.connector.interfaces
>>> gsm = zope.component.getGlobalSiteManager()
>>> connector = Connector()
>>> gsm.registerUtility(
...     connector, zeit.connector.interfaces.IConnector)


Create a fake content object:


>>> import zeit.cms.interfaces
>>> class Content(object):
...     zope.interface.implements(zeit.cms.interfaces.ICMSContent)
...     uniqueId = 'foo'

Lockstorage
===========

The lockstorage object is the mediator between Zope and the connector.

>>> import zeit.cms.locking.locking
>>> lock_storage = zeit.cms.locking.locking.LockStorage()

Its `getLock` method return an Lockinfo object when the resource is locked,
None when it's not:

>>> content = Content()
>>> lock_storage.getLock(content) is None
True


When who or until is not None we'll get a lock info:

>>> connector.who = 'bastard locker from hell'
>>> info = lock_storage.getLock(content)
>>> info.principal_id
'bastard locker from hell'


When the connector tells us that it is not us who locked but a different system
the lock owner will be prefixed by "othersystem.":

>>> connector.mylock = False
>>> info = lock_storage.getLock(content)
>>> info.principal_id
'othersystem.bastard locker from hell'

Set until:

>>> import datetime
>>> import pytz
>>> connector.who = None
>>> connector.until = datetime.datetime.now(pytz.UTC) + datetime.timedelta(
...     days=1)
>>> connector.mylock = True
>>> info = lock_storage.getLock(content)
>>> info.principal_id
u'zeit.cms.unknown-dav-locker'
>>> isinstance(info.timeout, float)
True

Getting a lock for a non-cms object also returns None:

>>> lock_storage.getLock(object()) is None
True

Setting a lock for a non-cms object raises an error:

>>> lock_storage.setLock(object(), info)
Traceback (most recent call last):
    ...
ValueError: Non CMS objects cannot be locked.

Deleting a lock for a non-cms object does nothing because it cannot be locked
anyway:

>>> lock_storage.delLock(object())


Clean up
========

>>> gsm.unregisterUtility(
...     connector, zeit.connector.interfaces.IConnector)
True

