===============
Navigation Tree
===============

Create a browser first:
    
>>> import lxml.etree
>>> from z3c.etestbrowser.testing import ExtendedTestBrowser
>>> browser = ExtendedTestBrowser()
>>> browser.addHeader('Authorization', 'Basic user:userpw')
>>> browser.xml_strict = True
>>> ns_map = {'html': 'http://www.w3.org/1999/xhtml'}


Tree Rendering
==============

The tree is rendered  in the sidebar all the time:

>>> browser.open('http://localhost/++skin++cms/')
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
  <ul>
      <li active="True" class="Root">
        <a href="...">Repository</a>
        ...
        <ul>
          <li...online...
          <li...2007...
        </ul>
      </li>
   </ul>
</div>


When we visit `online` it is automatically expanded while visiting it:

>>> browser.open('http://localhost/++skin++cms/repository/online')
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
 <ul>
    <li active="True" class="Root">
      <a href="...">Repository</a>
      ...
      <ul>
        <li...online...
          <ul>
            <li...2007...
          </ul>
        </li>
        <li...2007...
      </ul>
    </li>
 </ul>
</div>


Now we expand online/2007. This is done via an ajax request. Thus the returned
"page" only conatains the tree, not the full html page:

>>> import urllib
>>> view_url = 'http://localhost/++skin++cms/repository'
>>> browser.open('http://localhost/++skin++cms/repository/tree.html/'
...              '@@expandTree?uniqueId=http://xml.zeit.de/online'
...              '&view_url=%s' % urllib.quote(view_url))
>>> print lxml.etree.tostring(browser.etree, pretty_print=True)
<ul>
    <li active="True" class="Root">
      <a href="...">Repository</a>
      ...
      <ul>
        <li...online...
          <ul>
            <li...2007...
          </ul>
        </li>
        <li...2007...
      </ul>
    </li>
 </ul>


Since we've explicitly expanded the tree via an ajax request (i.e. by clicking
on the + icon) the tree stays expanded even when we're not inside online:

>>> browser.open('http://localhost/++skin++cms/repository')
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
  <ul>
      <li active="True" class="Root">
        <a href="...">Repository</a>
        ...
        <ul>
          <li...online...
            <ul>
              <li...2007...
            </ul>
          </li>
          <li...2007...
        </ul>
      </li>
   </ul>
</div>


Hidden Containers
=================

Users often do not want to see certain containers, so they can hide them.
Initially most containers are hidden actually. If 2006 was shown it would be
between online/2007 and 2007:

>>> print browser.contents
<?xml ...
      <li action="expand" class="NotRoot"
          uniqueid="http://xml.zeit.de/online/2007">
        <a href="http://localhost/++skin++cms/repository/online/2007">2007</a>
        <span class="URL">http://localhost/++skin++cms/repository/online/2007</span>
      </li>
  </ul>
      </li>
      <li action="expand" class="NotRoot"
          uniqueid="http://xml.zeit.de/2007">
        <a href="http://localhost/++skin++cms/repository/2007">2007</a>
        <span class="URL">http://localhost/++skin++cms/repository/2007</span>
      </li>
  </ul>
      </li>
  </ul>
  ...


When we are *inside* a hidden container, it is shown nevertheles:

>>> browser.open('http://localhost/++skin++cms/repository/2006')
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
  <ul>
      <li active="True" class="Root">
        <a href="...">Repository</a>
        ...
        <ul>
          <li...online...
            <ul>
              <li...2007...
            </ul>
          </li>
          <li...2006...
          <li...2007...
        </ul>
      </li>
   </ul>
</div>


Let's explicitly "show' the 2006 container now:

>>> browser.open('http://localhost/++skin++cms/repository/2006')
>>> browser.getLink('Show').click()

The navigation tree contains the 2006 even when looking at the root:

>>> browser.open('http://localhost/++skin++cms/repository/')
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
  <ul>
      <li active="True" class="Root">
        <a href="...">Repository</a>
        ...
        <ul>
          <li...online...
            <ul>
              <li...2007...
            </ul>
          </li>
          <li...2006...
          <li...2007...
        </ul>
      </li>
   </ul>
</div>

A shown container cant't be shown twice:

>>> browser.getLink('Show')
Traceback (most recent call last):
    ...
LinkNotFoundError

A shown container can be hidden again though:

>>> browser.getLink('Hide').click()
>>> navtree = browser.etree.xpath("//html:div[@id='navtreecontents']",
...                                ns_map)[0]
>>> print lxml.etree.tostring(navtree, pretty_print=True)
<div xmlns="http://www.w3.org/1999/xhtml" id="navtreecontents"...>
  <ul>
      <li active="True" class="Root">
        <a href="...">Repository</a>
        ...
        <ul>
          <li...online...
            <ul>
              <li...2007...
            </ul>
          </li>
          <li...2007...
        </ul>
      </li>
   </ul>
</div>

Now, of course, after showing, the `Hide` action is no longer available:

>>> browser.getLink('Hide')
Traceback (most recent call last):
    ...
LinkNotFoundError


Highlighting
============

The tree indicates where the user is right now. Create a test request:

>>> class Request(object):
...     view_url = None
...     def __init__(self, path, view_path=None):
...         self.path = path
...         self.application_url = 'http://127.0.0.1/++skin++cms'
...         self.URL = self.application_url + path
...         if view_path:
...             self.view_url = self.application_url + view_path
...     def get(self, key):
...         return self.view_url
...     def getURL(self):
...         return self.URL
...     def getApplicationURL(self):
...         return self.application_url


Create a tree and verify the normal highlighting:

>>> from zeit.cms.repository.browser.repository import Tree
>>> tree = Tree(object(), Request('/testing/@@view.html'))
>>> tree.selected('http://127.0.0.1/++skin++cms/foo')
False
>>> tree.selected('http://127.0.0.1/++skin++cms/testing')
True
>>> tree.selected('http://127.0.0.1/++skin++cms/test')
False

>>> tree = Tree(object(), Request('/testing/art/@@view.html'))
>>> tree.selected('http://127.0.0.1/++skin++cms/testing')
True
>>> tree.selected('http://127.0.0.1/++skin++cms/testing/art')
True
>>> tree.selected('http://127.0.0.1/++skin++cms/test/art')
False


When the tree is reloaded the url of the request cannot be used as indicator.
Therefore a `view_url` can be passed:

>>> tree = Tree(object(), Request(
...     '/foo/@@edit.html', view_path='/testing/@@view.html'))
>>> tree.selected('http://127.0.0.1/++skin++cms/testing')
True
