==============
PRISM Keywords
==============

Keywords Utility
================

The keywords are provided in the PRISM format. The Keyword Utility provides the
keywords to the CMS:

>>> import zeit.cms.content.keyword
>>> keywords = zeit.cms.content.keyword.KeywordUtility()
>>> root = keywords.root
>>> root.label
u'Themen der Zeit'
>>> root.code
u'TdZ'
>>> root.broader is None
True
>>> root.narrower
[<zeit.cms.content.keyword.Keyword object at 0x...>,
 <zeit.cms.content.keyword.Keyword object at 0x...>,
 ...]
>>> root.inTaxonomy
True
>>> politik = root.narrower[0]
>>> politik.label
u'Politik'
>>> politik.code
u'Politik'
>>> politik.broader == root
True
>>> politik.inTaxonomy
True

When we ask the utility for a keyword which is not in the PRISM file a KeyError
is raised:

>>> keywords['foo']
Traceback (most recent call last):
    ...
KeyError: 'foo'


The ``find_keywords`` method returns a list of matching keywords (substring):

>>> list(keywords.find_keywords('staat'))
[<zeit.cms.content.keyword.Keyword object at 0x...>, ...]
>>> import pprint
>>> pprint.pprint(sorted([kw.label for kw in keywords.find_keywords('staat')]))
[u'Sozialstaat',
 u'Staat',
 u'Staat',
 u'Staatliche Sozialleistung',
 u'Staatsangeh\xf6rigkeit',
 u'Staatsanwaltschaft',
 u'Staatsbesuch',
 u'Staatsdefizit',
 u'Staatsfinanzen',
 u'Staatsfinanzen',
 u'Staatsgrenze',
 u'Staatsoberhaupt',
 u'Staatsorgane',
 u'Staatsquote',
 u'Staatssymbol',
 u'Staatsverschuldung',
 u'Verstaatlichung']

We've got some labels twice – but they're twice int he ontology, so thats
correct.

Umlauts also work; and we're looking into the labels:

>>> sorted([kw.label for kw in keywords.find_keywords(u'\xe4si')])
[u'Pr\xe4sident']


Keywords Property
=================

The keyword property maps the `<keywordset>` to tuple of Keyword objects.
Create some mock content first:

>>> import lxml.objectify
>>> import lxml.etree
>>> class Content(object):
...     keywords = zeit.cms.content.keyword.KeywordsProperty()
>>> content = Content()
>>> content.xml = lxml.objectify.fromstring(
...     '<a xmlns:lxml="http://codespeak.net/lxml/objectify/pytype"/>')

The `KeywordsProperty` requires an `IKeywords` utility, so we register one:

>>> import zope.component
>>> gsm = zope.component.getGlobalSiteManager()
>>> gsm.registerUtility(keywords, zeit.cms.content.interfaces.IKeywords)

Initially the keywords is empty:

>>> content.keywords
()

Set a keyword:

>>> content.keywords = (keywords['STAA'], )
>>> content.keywords
(<zeit.cms.content.keyword.Keyword object at 0x...>,)
>>> content.keywords[0].code
u'STAA'
>>> content.keywords[0].label
u'Staat'

>>> print lxml.etree.tostring(content.xml, pretty_print=True)
<a xmlns:lxml="http://codespeak.net/lxml/objectify/pytype">
  <head>
    <keywordset>
      <keyword lxml:pytype="str" source="manual">STAA</keyword>
    </keywordset>
  </head>
</a>


Add another keyword:

>>> content.keywords = (keywords['STAA'], keywords['INNE'])
>>> content.keywords
(<zeit.cms.content.keyword.Keyword object at 0x...>,
 <zeit.cms.content.keyword.Keyword object at 0x...>)

>>> print lxml.etree.tostring(content.xml, pretty_print=True)
<a xmlns:lxml="http://codespeak.net/lxml/objectify/pytype">
  <head>
    <keywordset>
      <keyword lxml:pytype="str" source="manual">STAA</keyword>
      <keyword lxml:pytype="str" source="manual">INNE</keyword>
    </keywordset>
  </head>
</a>


Make sure invalid keywords are ignored:

>>> content.xml = lxml.objectify.fromstring('''\
...  <a xmlns:lxml="http://codespeak.net/lxml/objectify/pytype">
...   <head>
...     <keywordset>
...       <keyword lxml:pytype="str" source="manual">foobar</keyword>
...     </keywordset>
...   </head>
... </a>''')
>>> content.keywords
()

Clean up and unregister the utility:

>>> gsm.unregisterUtility(keywords, zeit.cms.content.interfaces.IKeywords)
True


Automatic reloading
===================

Key words are automatically reloaded every 5 minutes:

>>> keywords.reload_interval
datetime.timedelta(0, 360)

So let's change the keyword url to some minimal file:

>>> import tempfile
>>> new_keywords = tempfile.NamedTemporaryFile()
>>> new_keywords.write("""\
...   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:pcv="http://prismstandard.org/namespaces/1.2/pcv/" xml:base="http://namespaces.zeit.de/cv/themen.rdf">
...     <pcv:Descriptor rdf:ID="TdT">
...      <pcv:code>TdT</pcv:code>
...      <pcv:label>Themen des Tests</pcv:label>
...      <pcv:narrowerTerm rdf:resource="Politik" />
...     </pcv:Descriptor>
...     <pcv:Descriptor rdf:ID="Politik">
...      <pcv:code>Politik</pcv:code>
...      <pcv:label>Politik</pcv:label>
...      <pcv:broaderTerm rdf:resource="TdT" />
...     </pcv:Descriptor>
...   </rdf:RDF>
... """)
>>> new_keywords.flush()



>>> cms_config = zope.app.appsetup.product.getProductConfiguration('zeit.cms')
>>> cms_config['source-keyword'] = 'file://' + new_keywords.name

We still can read the old keywords since 5 minutes have not passed:

>>> keywords.root.label
u'Themen der Zeit'

Decrease the time to let the keywords utility reload its data:

>>> import datetime
>>> import time
>>> keywords.reload_interval = datetime.timedelta(seconds=1)
>>> time.sleep(1)

The keywords were reloaded now:

>>> keywords.root.label
u'Themen des Tests'

When the keyword file doesn't parse nothing bad happens – the old values are
kept:

>>> new_keywords.seek(0)
>>> new_keywords.write('foo')
>>> new_keywords.flush()
>>> time.sleep(1)
>>> keywords.root.label
u'Themen des Tests'

Reset the reload_interval to 5 minutes:

>>> keywords.reload_interval = datetime.timedelta(seconds=360)
