==============
DAV Properties
==============

The DAV properties map properties from the WebDAV properties dictionary to
python values.

Plain Unicode Values
====================

Plain unicode values can be mapped if the field implements IFromUnicode. The
mapping from the internal value to unicode just uses `unicode()`.

A plain text field:

>>> import zeit.cms.content.interfaces
>>> import zope.schema

>>> text_field = zope.schema.Text()
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(text_field)
>>> converter
<zeit.cms.content.dav.UnicodeProperty object at 0x...>
>>> converter.fromProperty('a text')
u'a text'
>>> converter.fromProperty(u'another text')
u'another text'
>>> converter.fromProperty(u'')
u''
>>> converter.toProperty(u'')
u''
>>> converter.toProperty(u'Foo')
u'Foo'


Try this for some fields. Integer goes first:

>>> int_field = zope.schema.Int()
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(int_field)
>>> converter
<zeit.cms.content.dav.UnicodeProperty object at 0x...>
>>> converter.fromProperty('5')
5
>>> converter.fromProperty('text')
Traceback (most recent call last):
    ...
ValueError: invalid literal for int(): text


The other way round is handled by the toProperty method:

>>> converter.toProperty(5)
u'5'
>>> converter.toProperty(1234)
u'1234'


Floats are also supported:


>>> float_field = zope.schema.Float()
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(float_field)
>>> converter
<zeit.cms.content.dav.UnicodeProperty object at 0x...>
>>> converter.fromProperty(5)
5.0
>>> converter.fromProperty(5.25)
5.25

>>> converter.fromProperty('text')
Traceback (most recent call last):
    ...
ValueError: invalid literal for float(): text

Convert float to property. Doesn't fail for integers of course:

>>> converter.toProperty(5.25)
u'5.25'
>>> converter.toProperty(593)
u'593'



Booleans
++++++++

The default representation of booleans is yes/no:

>>> field = zope.schema.Bool()
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(field)
>>> converter.fromProperty('yes')
True
>>> converter.fromProperty('no')
False

Python's True/False also works though:

>>> converter.fromProperty('True')
True
>>> converter.fromProperty('False')
False

Other, unknown values result in False:

>>> converter.fromProperty('foobar')
False

When converting a bool to a property, yes/no is always used:

>>> converter.toProperty(True)
'yes'
>>> converter.toProperty('another true value in python sense')
'yes'
>>> converter.toProperty(False)
'no'
>>> converter.toProperty(None)
'no'
>>> converter.toProperty([])
'no'


Choices
+++++++

How choices are stored in dav depends on the vocabulary or source. If the
source is iterable we assume that there are not many values, that is that it
doesn't harm to actually iterate over the source.

Iterable sources
----------------

For choices wich iterable sources tokenize the value before storing it to the
dav. There is a standard tokenizer for bool. So create a choice which allows
True and False:

>>> class BoolSource(list):
...     zope.interface.implements(zope.schema.interfaces.IIterableSource)
>>> field = zope.schema.Choice(source=BoolSource([True, False]))
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(field)
>>> converter.fromProperty('yes')
True
>>> converter.fromProperty('no')
False 

Other values result in ... currently a ValueError since I have no clue what
would be smart to do here:

>>> converter.fromProperty('dunno')
Traceback (most recent call last):
    ...
ValueError: dunno


Converting to a property results in the token:

>>> converter.toProperty(True)
'yes'
>>> converter.toProperty(False)
'no'

It is not checked if the value actually is valid for the field as this is not
the resposonsibility of the dav integration. So we'd get any available token
back.  For some arbitrary object we get a TypeError since we could not get a
token:

>>> converter.toProperty(object())
Traceback (most recent call last):
    ...
TypeError: ('Could not adapt',
            <object object at 0x...>,
            <InterfaceClass zeit.cms.content.interfaces.IDAVToken>)


Content sources
---------------

There is another implementation for ICMSContentSources. It stores the Unique Id
of the object and gets the object back from the unique id. We use the folder
source here to show that content is only returned if it is actually in the
source (setup functional test first):

>>> import zope.app.component.hooks
>>> old_site = zope.app.component.hooks.getSite()
>>> zope.app.component.hooks.setSite(getRootFolder())

>>> field = zope.schema.Choice(
...     source=zeit.cms.content.contentsource.FolderSource())
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(field)
>>> folder = converter.fromProperty(u'http://xml.zeit.de/online')
>>> folder
<zeit.cms.repository.folder.Folder object at 0x...>
>>> folder.uniqueId
u'http://xml.zeit.de/online'

When a unique id references an object wich doesn't exist, None is returned:

>>> converter.fromProperty(u'http://xml.zeit.de/online/gibtsnich') is None
True

Wehen a unique id references an object which exists but is not contained in the
source, None is returned, too:

>>> converter.fromProperty(
...     'http://xml.zeit.de/online/2007/01/thailand-anschlaege') is None
True

Restore old site:
>>> zope.app.component.hooks.setSite(old_site)

The other way round stores the unique id:

>>> converter.toProperty(folder)
u'http://xml.zeit.de/online'


Datetime
++++++++

Datetimes are stored in iso 8601 format:

>>> field = zope.schema.Datetime()
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(field)
>>> converter.fromProperty('2007-05-25T13:24:59Z')
datetime.datetime(2007, 5, 25, 13, 24, 59,
                  tzinfo=<iso8601.iso8601.Utc object at 0x...>)

>>> converter.fromProperty('2007-06-12T09:10:00+00:00')
datetime.datetime(2007, 6, 12, 9, 10, tzinfo=<FixedOffset '+00:00'>)

When the date is invalid, None is returned:

>>> print converter.fromProperty('asdf')
None

Converting datetimes takes timezone info into account:

>>> import datetime
>>> import pytz
>>> converter.toProperty(datetime.datetime(
...     2004, 1, 4, 10, 32, tzinfo=pytz.timezone('Europe/Berlin')))
'2004-01-04T10:32:00+01:00'


Tuple of TextLine
+++++++++++++++++

Tuples of TextLine are serialised with a semicolon as separator. 

>>> field = zope.schema.Tuple(
...     value_type=zope.schema.TextLine(),
...     default=())
>>> converter = zeit.cms.content.interfaces.IDAVPropertyConverter(field)
>>> converter.fromProperty('Peter Buhr;Klaus Kleber')
(u'Peter Buhr', u'Klaus Kleber')

A single author also gives a tuple:

>>> converter.fromProperty('Klaus Kleber')
(u'Klaus Kleber',)


The other way round, items are joined with a semicolon:

>>> converter.toProperty(('Peter Buhr', 'Klaus Kleber'))
u'Peter Buhr;Klaus Kleber'

In case there is a semicolon in a value, it will be escaped:

>>> converter.toProperty(('Peter Buhr', 'Klaus; Kl;eb;er'))
u'Peter Buhr;Klaus\\; Kl\\;eb\\;er'

Make sure the DAV value is correctl converted back to a tuple:

>>> converter.fromProperty(u'Peter Buhr;Klaus\\; Kl\\;eb\\;er')
(u'Peter Buhr', u'Klaus; Kl;eb;er')



LXML Values
===========

More complex values will be processes as lxml objectify nodes. This is not
impelemnted yet, therefor we haven't got tests.


DAVProperty
===========

The `DAVProperty` class is there to easily map attributes to WebDAV properties.
Let's create a little content class:

>>> import zope.interface
>>> import zeit.cms.interfaces
>>> from zeit.cms.content.dav import DAVProperty
>>> class Content(object):
...     properties = {}
...     title = DAVProperty(zope.schema.TextLine(), 'myns', 'title')
...
>>> def contentDavProps(context):
...     return context.properties
>>> site_manager = zope.app.component.hooks.getSiteManager()
>>> site_manager.registerAdapter(
...     contentDavProps,
...     (Content, ), zeit.cms.interfaces.IWebDAVProperties)
>>> content = Content()

When properties change an IDAVPropertyChangedEvent is issued. Register a
subscriber:

>>> import zope.app.component.hooks
>>> import zope.component
>>>
>>> def print_change(object, event):
...     print "Event:", event
...     print "    Old:", event.old_value
...     print "    New:", event.new_value
...     print "    NS:", event.property_namespace
...     print "    Name:", event.property_name
...
>>> site_manager.registerHandler(
...     print_change,
...     (Content,
...      zeit.cms.content.interfaces.IDAVPropertyChangedEvent))

As the properties dictionary is empty, we'll get the title's default value from
the field:

>>> print content.title
None

Setting the title will fill the properties dictionary with the name and
namespace:

>>> content.title = 'Mary had a little lamb.'
Event: <zeit.cms.content.interfaces.DAVPropertyChangedEvent object at 0x...>
    Old: None
    New: Mary had a little lamb.
    NS: myns
    Name: title

>>> content.properties
{('title', 'myns'): u'Mary had a little lamb.'}


When we set the title to None again, the property will be marked as to be
deleted:

>>> content.title = None
Event: <zeit.cms.content.interfaces.DAVPropertyChangedEvent object at 0x...>
    Old: Mary had a little lamb.
    New: DeleteProperty
    NS: myns
    Name: title
>>> content.properties
{('title', 'myns'): DeleteProperty}
>>> content.title is None
True


Remove the event listener and adapter:

>>> site_manager.unregisterHandler(
...     print_change,
...     (Content,
...      zeit.cms.content.interfaces.IDAVPropertyChangedEvent))
True
>>> site_manager.unregisterAdapter(
...     contentDavProps,
... (Content, ), zeit.cms.interfaces.IWebDAVProperties)
True
